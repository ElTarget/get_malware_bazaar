import shutil
import os
import threading

import requests


def file_transfer_handler(default_dir, target_dir):
    """
    移动文件夹 file_transfer_handler('../SaveFile', '../targetFile')
    :param default_dir: 默认存储路径
    :param target_dir: 目标路径
    :return:
    """
    try:
        if not os.path.exists(target_dir):
            os.makedirs(target_dir)
        shutil.move(default_dir, target_dir)
        print('移动完成: ', target_dir)
        return True
    except Exception as e:
        print(e)
        return False


# 定义下载函数
def url_response(url):
    path = url.split('/')[-1]
    r = requests.get(url, stream=True)
    with open(path, 'wb') as f:
        for ch in r:
            f.write(ch)
    f.close()


def save_range_handler(start, end, url, filename):
    header = {'Range': 'bytes=%d-%d' % (start, end)}
    with requests.get(url, headers=header, stream=True) as r:
        with open(filename, "r+b") as fp:
            fp.seek(start)
            var = fp.tell()
            fp.write(r.content)


def range_download(url, num_thread=5):
    file_name = url.split('/')[-1]
    r = requests.head(url)
    try:
        file_size = int(r.headers['content-length'])
    except:
        print("检查URL，或不支持对线程下载", url)
        return
    fp = open(file_name, "wb")
    fp.truncate(file_size)
    fp.close()
    part = file_size // num_thread
    for i in range(num_thread):
        start = part * i
        end = file_size if i == num_thread - 1 else start + part
        t = threading.Thread(target=save_range_handler,
                             kwargs={'start': start, 'end': end, 'url': url, 'filename': file_name})
        t.setDaemon(True)
        t.start()
    # 等待所有线程下载完成
    main_thread = threading.current_thread()
    for t in threading.enumerate():
        if t is main_thread:
            continue
        t.join()

    print('%s 下载完成' % file_name)
